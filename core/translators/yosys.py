import csv
import textwrap
from io import StringIO
from pathlib import Path

import pysmt.smtlib.commands as smtcmd
from pysmt.fnode import FNode
from pysmt.shortcuts import TRUE, And, FreshSymbol
from pysmt.smtlib.parser import SmtLibParser
from pysmt.substituter import FunctionInterpretation
from pysmt.typing import BOOL

from core.circuits.cpp import YosysCppCircuit
from core.circuits.smt import YosysSmtCircuit
from core.circuits.verilog import VerilogCircuit, VerilogNetList
from core.consts import (CXXRTL_CLK_FUNC_DEF, CXXRTL_DEBUG_EVAL_FUNC_DEF, CXXRTL_DEBUG_EVAL_STMT, LL_DEBUG_INFO,
                         SIMPLE_IDENTIFIER, SMT2_ACCESSOR_NAME, SMT2_INITIAL_STATE, SMT2_OTHER_HIERARCHY,
                         SYM_EXE_CPP_TEMPLATE)
from core.ir.crossbar import YosysCxxCrossbar, YosysSmtCrossbar
from core.ir.view import ModelTreeView
from core.thirdparty import dump_debug_info, yosys_compile, yosys_synthesis, yosys_write_cxxrtl, yosys_write_smt2
from core.translators.translator import CmdlineOption, MetaTranslator
from core.workspace import get_workspace


def _function_maker(name, params, body):

    def pysmt_func(*args):
        if len(args) != len(params):
            raise TypeError(f'{name}() takes {len(params)} argument(s) ({len(args)} given)')
        mapping = {p: a for p, a in zip(params, args)}
        return body.substitute(mapping)

    return pysmt_func


class YosysWriteSmt2(MetaTranslator):
    edges = [(VerilogCircuit, YosysSmtCircuit)]

    def translate(self, circuit: VerilogCircuit) -> YosysSmtCircuit:
        """Transform the given VerilogCircuit `verilog_circ` into an SmtCircuit
        with `yosys`.

        From the SMT-LIBv2 file generated by yosys, loads the definitions of
        the state sort, signals in the design and other functions. Returns a
        tuple (state, relation, top_module).

        (Assume the name of current module is `<mod>`. Each script may contain
        more than one module. We treat the `top` module specially.)

        - state: the sort `<mod>_s` where `<mod>` is `top`
                (a.k.a. state of the top module)
        - relation: the transition function `<mod>_t` and the hierarchy
                    function `<mod>_h`
        - top_module: the top-level module of given design
                      (containing its submodules)

        Commands of our interest in the script:

        1. `(declare-sort |<mod>_s| 0)`: The sort representing a state of
        the module `<mod>`.

        2. `(define-fun |<mod>_h| ((state |<mod>_s|)) Bool (...))`: This
        function must be asserted for each state to establish the design
        hierarchy.

        3. `(define-fun |<mod>_n <wirename>| (|<mod>_s|) (_ BitVec <width>))`
        or `(define-fun |<mod>_n <wirename>| (|<mod>_s|) Bool)`: For each port,
        register, and wire with the 'keep' attribute set an accessor function
        is generated. Single-bit wires are returned as Bool, multi-bit wires as
        BitVec.

        4. `(define-fun |<mod>_t| ((state |<mod>_s|) (next_state |<mod>_s|))
        Bool (...))`: This function evaluates to 'true' if the states 'state'
        and 'next_state' form a valid state transition.

        5. `(declare-fun |<mod>_is| (|<mod>_s|) Bool)`: This function must be
        asserted 'true' for initial states, and 'false' otherwise.

        (Reference: Yosys Manual)"""

        workspace = get_workspace()
        yosys_model = ModelTreeView.from_module_decl(circuit.model)
        top_module = yosys_model.top_module()

        # call yosys (use -qq to suppress all warnings)
        verilog_file = workspace.save_to_file(circuit.data, 'write_smt2_input.v')
        smt_output = yosys_write_smt2(workspace.context, verilog_file.as_posix(), top_module)

        # First write the output to a file.
        # If it exited unexpectedly during parsing, a yosys file will be already there for bug location.
        workspace.save_to_file(smt_output, 'yosys.smt2')

        # parse output by pySMT
        with StringIO(smt_output) as buffer:
            script = SmtLibParser().get_script(buffer)

        # helper functions
        is_top_sort_decl = lambda n: n == f'{top_module}_s'
        is_top_hierarchy = lambda n: n == f'{top_module}_h'
        is_top_transition = lambda n: n == f'{top_module}_t'

        match_initial_state = lambda n: SMT2_INITIAL_STATE.match(n)

        replace_with_true = set()

        # Save function definitions in the result circuit for further use
        function_definitions = dict()

        match_var_accessor = lambda n: SMT2_ACCESSOR_NAME.match(n)
        match_hierarchy_function = lambda n: SMT2_OTHER_HIERARCHY.match(n)

        # type of the top module's state
        state_type = None

        for cmd in script.commands:
            if cmd.name == smtcmd.DECLARE_SORT:
                smt_type = cmd.args[0]
                if is_top_sort_decl(smt_type.name):
                    state_type = smt_type

            elif cmd.name == smtcmd.DEFINE_FUN:
                func_name, params, return_type, func_body = cmd.args
                defined_func = _function_maker(func_name, params, func_body)

                if is_top_hierarchy(func_name):
                    top_h = defined_func
                elif is_top_transition(func_name):
                    top_t = defined_func
                elif m := match_hierarchy_function(func_name):
                    function_definitions[func_name] = defined_func
                elif m := match_var_accessor(func_name):
                    function_definitions[func_name] = defined_func

                    width = 1 if return_type == BOOL else return_type.width
                    cb = YosysSmtCrossbar.from_data(m.groups('mod wirename'), yosys_model)
                    for p in cb.to_model():
                        yosys_model.instantiate_item(p)
            elif cmd.name == smtcmd.DECLARE_FUN:
                uninterpreted_func = cmd.args[0]
                func_name = uninterpreted_func.symbol_name()

                if m := match_hierarchy_function(func_name):
                    function_definitions[func_name] = uninterpreted_func
                elif m := match_initial_state(func_name):
                    replace_with_true.add(uninterpreted_func)

        if state_type is None:
            raise ValueError(f'cannot find the state type of top module')

        def valid_transition(state, next_state) -> FNode:
            return top_t(state, next_state)

        def precondition(state, next_state) -> FNode:
            origin_version = And(top_h(state), top_h(next_state))
            return origin_version.substitute(subs=None,
                                             interpretations={
                                                 uf:
                                                 FunctionInterpretation(
                                                     [FreshSymbol(t) for t in uf.symbol_type().param_types], TRUE())
                                                 for uf in replace_with_true
                                             })

        return YosysSmtCircuit(valid_transition, yosys_model, state_type, precondition, function_definitions)


class YosysWriteCxx(MetaTranslator):
    edges = [(VerilogCircuit, YosysCppCircuit)]

    alternative_options = [
        CmdlineOption('-print-wire-types'),
        CmdlineOption('-print-debug-wire-types'),  # enable additional debug logging
        CmdlineOption('-nohierarchy'),  # use design hierarchy as-is
        CmdlineOption('-O{}', range(6 + 1)),  # set the optimization level
    ]

    def translate(self, circuit: VerilogCircuit) -> YosysCppCircuit:
        workspace = get_workspace()
        cpp_model = ModelTreeView.from_module_decl(circuit.model)
        top_module = cpp_model.top_module()
        mangled_top_module = YosysCxxCrossbar.mangle_name(top_module)

        # Create a directory to save C++ source files and compiler outputs
        output_dir = workspace.path_to_temp_dir('yosys-write-cxxrtl')
        output_dir.mkdir(parents=True, exist_ok=True)

        # Call Yosys to transform the data
        verilog_file = workspace.save_to_file(circuit.data, 'write_cxxrtl_input.v')
        yosys_write_cxxrtl(workspace.context, verilog_file.as_posix(), top_module, output_dir.as_posix(),
                           self.policy['extra_args'])

        # Generate debug_info.csv
        dump_debug_info(workspace.context, mangled_top_module, output_dir.as_posix())

        # Create driver logic in the main function
        debug_items = self._parse_debug_info(output_dir)
        cxx_impl_items = YosysCxxCrossbar.preprocess(debug_items, cpp_model)
        self._generate_driver(mangled_top_module, output_dir, cxx_impl_items)

        # Build the C++ files generated above.
        # Then extract bitcode (.bc) and llvm assembly (.ll) files
        yosys_compile(workspace.context, top_module, output_dir.as_posix())

        # Transform the model
        cxx_variable_names = {x.cxx_name for x in cxx_impl_items}
        self._fulfill_model(cpp_model, output_dir, cxx_variable_names)

        return YosysCppCircuit(output_dir, cpp_model)

    def _parse_debug_info(self, output_dir: Path):
        """Collect names of debug items for main() function generation."""

        result = list()
        with open(output_dir / 'debug_info.csv', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                name = row['name']
                # NOTE: drop the auto-generated signal names
                if SIMPLE_IDENTIFIER.fullmatch(name.split(sep=' ')[-1]):
                    result.append(
                        YosysCxxCrossbar.DebugItem(name=name,
                                                   width=int(row['width']),
                                                   writable_and_non_output=(row['next'] != '(nil)'
                                                                            and int(row['flags']) & 3 != 2)))
        return result

    def _generate_driver(self, mangled_top_module: str, output_dir: Path,
                         cxx_impl_items: list[YosysCxxCrossbar.CxxImplItem]) -> None:
        """Generate the main() function used later in the symbolic execution."""

        def c_type(bits: int) -> str:
            """Given number of bits, return the proper data type in C++."""
            if 0 <= bits <= 8:
                return 'uint8_t'
            elif bits <= 16:
                return 'uint16_t'
            elif bits <= 32 or bits > 64:
                return 'uint32_t'
            elif bits <= 64:
                return 'uint64_t'
            else:
                raise ValueError(f'illegal bit width {bits}')

        # Find the name of the clock signal in the header file
        clock_signal = None
        # Check whether the function `debug_eval()` is defined
        has_debug_eval = False

        for line in (l.strip() for l in open(output_dir / f'{mangled_top_module}.cpp', 'r')):
            if m := CXXRTL_CLK_FUNC_DEF.match(line):
                # NOTE: the function "posedge_p_{clk_name}()" always exists
                clock_signal = m.group('clk_name')
            elif m := CXXRTL_DEBUG_EVAL_FUNC_DEF.match(line):
                has_debug_eval = True

        set_posedge = f'top.p_{clock_signal}.set(true);' if clock_signal else ''

        # Remove the clock signal from cxx_impl_items
        cxx_impl_items = [x for x in cxx_impl_items if x.origin_name != clock_signal]

        struct_definition = list()
        snapshot_function_definition = list()
        initialization = list()

        for symbolic_item in cxx_impl_items:
            origin_name = symbolic_item.origin_name
            cxx_name = symbolic_item.cxx_name
            array_size = symbolic_item.array_size
            bit_width = symbolic_item.bit_width

            word_size = ((bit_width + 31) // 32) if bit_width > 64 else 1
            is_wide = word_size > 1
            is_array = array_size > 1

            data_type = c_type(bit_width)

            index_suffix = f'[j+i*{word_size}]' if is_wide or is_array else ''

            temp_var_name = 'temp'
            symbolic_var_name = 'name'
            base_var_name = 'base_name'

            # Struct field definition
            if is_wide or is_array:
                struct_definition.append(f'{data_type} {cxx_name}[{array_size * word_size}];')
            else:
                struct_definition.append(f'{data_type} {cxx_name};')

            # Getter in snapshot() function
            getter = list()

            getter.append(f'for (int i = 0; i < {array_size}; ++i) {{')
            getter.append(f'\tfor (int j = 0; j < {word_size}; ++j) {{')
            if is_array:
                getter.append(f'\t\tstd::string {base_var_name}("{origin_name}");')
                getter.append(
                    f'\t\ts.{cxx_name}{index_suffix} = items[{base_var_name}.append("[" + std::to_string(i) + "]")].curr[j];'
                )
            else:
                getter.append(f'\t\ts.{cxx_name}{index_suffix} = items["{origin_name}"].curr[j];')

            getter.append('\t}')
            getter.append('}')
            getter.append('')  # line break

            snapshot_function_definition.extend(getter)

            # Assign the symbolic values
            if symbolic_item.is_symbolic:

                setter = list()

                setter.append(f'for (int i = 0; i < {array_size}; ++i) {{')
                setter.append(f'\tfor (int j = 0; j < {word_size}; ++j) {{')

                setter.append(f'\t\t{data_type} {temp_var_name};')
                # NOTE: Names longer than this can cause KLEE exit early
                setter.append(f'\t\tchar {symbolic_var_name}[60];')
                if is_wide or is_array:
                    setter.append(f'\t\tsprintf({symbolic_var_name}, "%s_%d", "{cxx_name}", j+i*{word_size});')
                else:
                    setter.append(f'\t\tsprintf({symbolic_var_name}, "%s", "{cxx_name}");')
                setter.append(
                    f'\t\tklee_make_symbolic(&{temp_var_name}, sizeof({temp_var_name}), {symbolic_var_name});')
                if is_wide:
                    setter.append(f'\t\tif (j == {word_size} - 1)')
                    setter.append(f'\t\t\tklee_assume({temp_var_name} < (({data_type}) 1UL << {bit_width % 32}));')
                elif bit_width not in (8, 16, 32, 64):
                    setter.append(f'\t\tklee_assume({temp_var_name} < (({data_type}) 1UL << {bit_width}));')

                if is_array:
                    setter.append(f'\t\tstd::string {base_var_name}("{origin_name}");')
                    setter.append(f'\t\titems[{base_var_name}.append("[" + std::to_string(i) + "]")].next[j] = temp;')
                else:
                    setter.append(f'\t\titems["{origin_name}"].next[j] = temp;')

                setter.append('\t}')
                setter.append('}')
                setter.append('')  # line break

                initialization.extend(setter)

        # Generate the main.cpp file
        (output_dir / 'main.cpp').write_text(
            textwrap.dedent(
                SYM_EXE_CPP_TEMPLATE.format(top_module=mangled_top_module,
                                            struct_definition='\n\t\t'.join(struct_definition),
                                            snapshot_function_definition='\n\t\t'.join(snapshot_function_definition),
                                            initialization='\n\t\t'.join(initialization),
                                            debug_eval=CXXRTL_DEBUG_EVAL_STMT if has_debug_eval else '',
                                            set_posedge=set_posedge)))

    def _fulfill_model(self, model: ModelTreeView, target_dir: Path, cxx_variable_names: set[str]):
        """For each variable in the `cxx_variable_names`, find its debug info in the `.ll` file in target_dir.
        Its size and offset will be used to instantiate the model."""

        for line in open(target_dir / f'{model.top_module()}.ll', 'r'):
            if m := LL_DEBUG_INFO.match(line):
                cxx_name = m.group('name')  # name of the struct field
                size = int(m.group('size')) >> 3  # in byte
                offset = int(m.group('offset') or 0) >> 3  # in byte

                if cxx_name in cxx_variable_names:
                    crossbar = YosysCxxCrossbar.from_data(cxx_name, model)
                    for path in crossbar.to_model():
                        model.instantiate_item(path, bytes=size, offset=offset)


class YosysSynthesis(MetaTranslator):
    edges = [(VerilogCircuit, VerilogNetList)]

    alternative_options = [
        CmdlineOption('-flatten'),  # flatten the design before synthesis
        CmdlineOption('-lut {}', range(2, 10, 2)),  # perform synthesis for a k-LUT architecture
        CmdlineOption('-nofsm'),  # do not run FSM optimization
        CmdlineOption('-noabc'),  # do not run abc
        CmdlineOption('-noalumacc'),  # do not run 'alumacc' pass
        CmdlineOption('-nordff'),  # passed to ’memory’. prohibits merging of FFs into memory read ports
        CmdlineOption('-noshare'),  # do not run SAT-based resource sharing
        CmdlineOption('-run {}', ["coarse:fine", "fine"]),  # only run the commands between the labels
        CmdlineOption('-abc9'),  # use new ABC9 flow (EXPERIMENTAL)
        CmdlineOption('-flowmap -lut {}', range(2, 10, 2)),  # use FlowMap LUT techmapping instead of ABC
    ]

    def translate(self, circuit: VerilogCircuit) -> VerilogCircuit:
        workspace = get_workspace()
        verilog_file = workspace.save_to_file(circuit.data, 'synth_input.v')
        synthesized_verilog = yosys_synthesis(workspace.context, verilog_file.as_posix(), self.policy['extra_args'])
        synthesized_file = workspace.save_to_file(synthesized_verilog, 'synthesized.v')
        return VerilogCircuit.from_file(synthesized_file)
