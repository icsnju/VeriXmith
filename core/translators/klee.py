from io import StringIO
from pathlib import Path
from typing import Callable, Iterable, Iterator

import pysmt.smtlib.commands as smtcmd
from invoke.exceptions import CommandTimedOut
from pysmt.fnode import FNode
from pysmt.shortcuts import BV, And, BVExtract, EqualsOrIff, Or, Symbol
from pysmt.smtlib.parser import SmtLibParser
from pysmt.typing import BVType, FunctionType

from core.circuits.cpp import VerilatorCppCircuit, YosysCppCircuit
from core.circuits.smt import KleeSmtCircuit
from core.consts import KLEE_ARRAY_DECL, KLEE_ARRAY_TYPE, KLEE_STATE_TYPE
from core.ir.crossbar import KleeSmtCrossbar, VerilatorCppCrossbar
from core.thirdparty import symbolic_execution
from core.translators.translator import MetaTranslator
from core.workspace import get_workspace


class KleeOutputLoader:

    def __init__(self, klee_out_dir: Path, circuit: VerilatorCppCircuit | YosysCppCircuit, allow_partial: bool) -> None:
        self.circuit = circuit

        self.parser = SmtLibParser()

        self.allow_partial = allow_partial

        # Preconditions
        self.const_arr_bytes = list()

        # Indicators
        self.path_constraints = list()
        self.initial_states = list()
        self.next_states = list()

        # Initialize
        for smt2_file, snapshots_file in self._iter_raw_results(klee_out_dir):
            try:
                self._next_states_from(snapshots_file)
            except ValueError:
                if self.allow_partial:
                    continue  # Skip this pair of (path_constraints, next_states)
                else:
                    raise  # Abort
            self._path_constraints_from(smt2_file)

        assert len(self.path_constraints) == len(self.initial_states) == len(self.next_states)

    def _iter_raw_results(self, klee_out_dir: Path) -> Iterable[tuple[Path, Path]]:
        """Iterate over the files in klee's output directory."""

        index = 1  # fetch the (.snapshots, .smt2) by index
        while True:
            path_constraints = klee_out_dir / f'test{index:0>6}.smt2'
            next_states = path_constraints.with_suffix('.snapshots')
            if not (path_constraints.exists() and next_states.exists()):
                break
            yield path_constraints, next_states
            index += 1

    @property
    def substitution_rules(self) -> Callable[[FNode, FNode], tuple[dict[FNode, FNode], dict[FNode, FNode]]]:
        """In KLEE, all the symbolic variables (in this situation, they're wires, registers, and ports)
        are represented by the arrays in SMT-LIBv2.
        The real value of a symbol, which is a bit-vector, is constructed by the "array-selection" and
        "bit-vector concatenation" calculations.

        In our application, we must distinguish a register's value in the current cycle from its value
        in the last cycle.
        Thus, we turn an array into a function, which accepts a cycle and returns a bit-vector.

        Consider a typical path generated by KLEE. What we want is path constraints and next states.

        - For path constraints and right-hand-side expressions in next states:
            - wire & register => f(last_state)
        - For left-hand-side values in next states:
            - wire & register => f(current_state)

        The set of sub-expressions requiring replacement is a subset of the rules."""

        def substitution_rules_of(var: KleeSmtCrossbar.AtomVariable, state: FNode) -> Iterable[tuple[FNode, FNode]]:
            """Rules for each byte of every single variable."""

            # SMT-LIBv2 array declaration to be removed
            array = Symbol(var.name, KLEE_ARRAY_TYPE)
            # SMT-LIBv2 function to be added
            # NOTE: We define the variable-selection functions for all possible paths here.
            var_selector = Symbol(KleeSmtCrossbar.accessor_name(self.circuit.model.top_module(), var.name),
                                  FunctionType(BVType(var.bytes << 3), [KLEE_STATE_TYPE]))

            for i in range(var.bytes):
                array_selection = array.Select(BV(i, 32))
                # Given a pySMT formula of array selection `arr[i]`,
                # construct a new formula `arr(state)[i*8+7:i*8]`.
                yield (array_selection, BVExtract(var_selector(state), i * 8, i * 8 + 7))

        def intra_state_substitution_rule(state: FNode) -> dict[FNode, FNode]:
            """A "state" variable is needed to generate a concrete list of substitution rules.
            With the given "state" variable, the holes in the formulae in `substitution_rules_of()` is filled."""

            rules = dict()
            for variable in self.circuit.atom_variables(self.circuit.model.all_items):
                for before, after in substitution_rules_of(variable, state):
                    rules[before] = after
            return rules

        def concrete_rules(last_state: FNode, current_state: FNode) -> tuple[dict[FNode, FNode], dict[FNode, FNode]]:
            """A pair of rule sets are generated for "last state" and "current state" respectively at one time."""
            return intra_state_substitution_rule(last_state), intra_state_substitution_rule(current_state)

        return concrete_rules

    def _next_states_from(self, snapshots_file: Path) -> None:
        """Since the whole circuit is represented by a class in C++, state of
        the circuit can be obtained by inspecting the memory snapshot in the
        given `.snapshots` file.

        This method constructs a tuple `(variable, expression)` for every
        internal register in the C++ circuit.

        The structure of `.snapshots` file:

        ```
        (declare-fun ...)
        (assert ...)
        ---
        [ObjectState]
        ***
        (* repeat *)
        ```

        Returns pairs of next-state values."""

        def extract_declarations(header: str) -> str:
            """Returns all the array definitions in the header as a string.
            Used to construct a self-contained string for the smt2 parser."""

            result = ''
            for unit_declaration in header.split('\n'):
                if KLEE_ARRAY_DECL.match(unit_declaration):
                    result += unit_declaration
            return result

        def extract_preconditions(header: str) -> FNode:
            """Returns all the assertions in the header as an FNode."""

            script = self.parser.get_script(StringIO(header + '(check-sat)'))
            return script.get_strict_formula()

        def parse_expr_str(expr: str, declarations: str) -> FNode:
            """Convert the string `expr` into an pySMT expression object."""

            wrapped = f'{declarations}\n(define-fun F () (_ BitVec 8) {expr})'
            with StringIO(wrapped) as buffer:
                script = self.parser.get_script(buffer)
            return script.commands[-1].args[3]

        def pairs_of(var_name: str, exprs: list[FNode]) -> Iterable[tuple[FNode, FNode]]:
            """Pair each element of an array with a `Select` expression."""

            left_val = Symbol(var_name, KLEE_ARRAY_TYPE)
            for index, expr in enumerate(exprs):
                yield left_val.Select(BV(index, 32)), expr

        def all_snapshots() -> Iterable[tuple[str, str]]:
            """Simply split the .snapshots file.
            Yield one snapshot in the `(header, body)` form at a time."""

            header, body = '', ''
            in_header = True

            for line in open(snapshots_file, 'r'):
                if line == '***\n':
                    yield header, body
                    header, body = '', ''
                    in_header = True
                elif line == '---\n':
                    in_header = False
                elif in_header:
                    header += line
                elif not in_header:
                    body += line

        def parse_snapshot(header: str, body: str, const_arr_bytes: list[FNode]) -> Iterable[FNode]:
            """Extract the definitions of `const_arr`s and values of memory cells from the header and body.
            - The assertions on bytes of `const_arr`s will be appended to the `const_arr_bytes` list.
            - The values of memory cells will be evaluated when iterating the return value."""

            const_arr_bytes.append(extract_preconditions(header))

            declarations = extract_declarations(header)
            for expr in body.splitlines():
                yield parse_expr_str(expr, declarations)

        def extract_variables(atom_variables: Iterator[KleeSmtCrossbar.AtomVariable],
                              memory_cells: Iterable[FNode]) -> Iterable[tuple[str, list[FNode]]]:
            """Extract the interested atom variables from the memory cells. Return (name, values) tuples."""

            if not (next_var := next(atom_variables, None)):
                return

            buffer = list()  # save incomplete expression
            bytes_left = 0  # number of missing bytes in buffer

            for addr, cell in enumerate(memory_cells):
                if bytes_left == 0 and addr != next_var.offset:
                    continue
                elif bytes_left != 0 and addr == next_var.offset:
                    raise ValueError('Overlapping variables detected.')
                else:
                    if bytes_left == 0 and addr == next_var.offset:
                        # detect a new member variable
                        buffer.clear()
                        bytes_left = next_var.bytes  # directly use data in Cpp's Model

                    # collect byte value into buffer
                    buffer.append(cell)

                    # complete one variable
                    if (bytes_left := bytes_left - 1) == 0:
                        assert len(buffer) == next_var.bytes

                        yield next_var.name, buffer

                        if not (next_var := next(atom_variables, None)):
                            return

        def make_states(snapshot: tuple[str, str],
                        atom_variables: Iterable[KleeSmtCrossbar.AtomVariable]) -> Iterable[tuple[FNode, FNode]]:
            header, body = snapshot
            for name, cells in extract_variables(iter(atom_variables),
                                                 parse_snapshot(header, body, self.const_arr_bytes)):
                yield from pairs_of(name, cells)

        try:
            before_posedge, after_posedge, *_ = all_snapshots()
        except ValueError:
            if not self.allow_partial:
                raise ValueError(f'abort due to incomplete {snapshots_file.name}')
            else:
                return

        # Collect the values of INPUT ports and internal REGISTERS
        self.initial_states.append(
            list(make_states(before_posedge, self.circuit.atom_variables(self.circuit.model.combination_inputs))))

        # Collect the values of OUTPUT ports and internal REGISTERS
        self.next_states.append(
            list(make_states(after_posedge, self.circuit.atom_variables(self.circuit.model.combination_outputs))))

    def _path_constraints_from(self, smt2_file: Path) -> None:
        """Read the path constraints from the given `.smt2` file."""

        def remove_model_version(formula: FNode) -> FNode:
            """Replace the `model_version` array by a constant expression."""

            model_version = Symbol('model_version', KLEE_ARRAY_TYPE)
            one, *zeros = (model_version.Select(BV(i, 32)) for i in range(4))

            substitution = {zero: BV(0, 8) for zero in zeros}
            substitution[one] = BV(1, 8)
            return formula.substitute(substitution)

        with open(smt2_file, 'r') as buffer:
            script = self.parser.get_script(buffer)
        # Only the last assertion goes to PC.
        # Other assertions (definitions of const_arr) go to self.const_arr_bytes.
        *extra_assertions, pc = [cmd.args[0] for cmd in script.filter_by_command_name([smtcmd.ASSERT])]
        self.const_arr_bytes.extend(extra_assertions)
        # remove 'model_version' in path constraints
        self.path_constraints.append(remove_model_version(pc))

    @property
    def precondition_maker(self) -> Callable[[FNode, FNode], FNode]:
        """Construct the full precondition with:
        - Definitions of constant arrays."""

        def precondition(last_state: FNode, current_state: FNode) -> FNode:
            return And(*self.const_arr_bytes)

        return precondition

    @property
    def transformation_maker(self) -> Callable[[FNode, FNode], FNode]:
        """Return a list of paths.
        - Transformation: path constraints + next states, represented as a function f(s,s')->B."""

        def transformation(last_state: FNode, current_state: FNode) -> FNode:
            last_rule, current_rule = self.substitution_rules(last_state, current_state)

            # Apply substitutions with the rules above
            path_constraints = (pc.substitute(last_rule) for pc in self.path_constraints)
            next_states = (And(*(EqualsOrIff(lhs.substitute(current_rule), rhs.substitute(last_rule))
                                 for lhs, rhs in ns)) for ns in self.next_states)
            initial_states = (And(*(EqualsOrIff(lhs.substitute(last_rule), rhs.substitute(last_rule))
                                    for lhs, rhs in ls)) for ls in self.initial_states)

            return Or(*(And(ls, pc, ns) for ls, pc, ns in zip(initial_states, path_constraints, next_states)))

        return transformation


class KleeSymbolicExecution(MetaTranslator):
    edges = [(VerilatorCppCircuit, KleeSmtCircuit), (YosysCppCircuit, KleeSmtCircuit)]

    def translate(self, circuit: VerilatorCppCircuit | YosysCppCircuit) -> KleeSmtCircuit:

        workspace = get_workspace()
        is_partial = False

        # create output directory
        klee_out_dir = workspace.path_to_temp_dir('klee')
        # symbolic execution
        if isinstance(circuit, VerilatorCppCircuit):
            bc_file = f'V{VerilatorCppCrossbar.escape_name(circuit.model.top_module())}.bc'
        elif isinstance(circuit, YosysCppCircuit):
            bc_file = f'{circuit.model.top_module()}.bc'
        else:
            raise ValueError('unsupported input circuit')

        try:
            symbolic_execution(workspace.context, bc_file, klee_out_dir, circuit.data, list())
        except CommandTimedOut:
            is_partial = True

        # Parse the .smt2 and .snapshots files in klee_out_dir
        # to get all the paths (in SMT-LIBv2 format) in the executable.
        loader = KleeOutputLoader(klee_out_dir, circuit, is_partial)
        # (Still in transformation process, since the SmtCircuit is a bundle
        # including: (1) script; (2) relation; (3) state_type; (4) preconditions.)

        return KleeSmtCircuit(loader.transformation_maker, circuit.model, KLEE_STATE_TYPE, loader.precondition_maker,
                              is_partial)
