# VeriXmith

VeriXmith interlinks a broad array of tools associated with logical synthesis and simulation for cross-checking. It leverages the implicit semantic consistency between representations of one circuit design. Specifically, compilers and satisfiability solvers can be interconnected with semantics extractors to broaden the domain of semantically equivalent circuit representations applicable to cross-checking.

VeriXmith currently depends on (a.k.a. cross-checks) the following projects:

- [yosys](https://github.com/YosysHQ/yosys)
- [verilator](https://github.com/verilator/verilator)
- [iverilog](https://github.com/steveicarus/iverilog)
- [sv2v](https://github.com/zachjs/sv2v)
- [synlig](https://github.com/chipsalliance/synlig)
- [verismith](https://github.com/ymherklotz/verismith)
- [VlogHammer](https://github.com/YosysHQ/VlogHammer)
- [tree-sitter-verilog](https://github.com/tree-sitter/tree-sitter-verilog)
- [klee](https://github.com/klee/klee)

## Installation

The simplest way: run VeriXmith in Docker (zero configuration needed).

```
python3 -m tools.deploy update-image
```

will automatically build a docker image named `verixmith`, by calling the following command:

```
DOCKER_BUILDKIT=1 docker build --network=host --platform=linux/amd64 -t verixmith .
```

([Typer](https://typer.tiangolo.com/) is needed to run script `tools/deploy/__main__.py`.)

## Usage

There are three ways to work with VeriXmith:

1. VeriXmith can be used as a Python library. API functions such as `run_validation()` are provided in `core/api.py`.
2. VeriXmith uses [Invoke](https://www.pyinvoke.org/) to run its APIs from CLI. Therefore, one can use a command line like `inv run-validation ...` to run VeriXmith. Run `inv --list` to see all available tasks.
3. `tools/deploy/__main__.py` is a script built on top of `tasks.py`. It is helpful when starting a group of experiments on remote servers is needed.

### Getting Started

Start a cross-checking process with a fixed set of Verilog or SystemVerilog examples:

```
python3 -m tools.deploy batch-test example1 examples/verilog/ results/ 10 VerilogCircuit SmtCircuit
python3 -m tools.deploy batch-test example2 examples/systemverilog/ results/ 10 SystemVerilogCircuit VerilogCircuit
```

- **Explanation**: `batch-test` searches input programs from `examples/verilog/` (or `examples/systemverilog/`), samples `10` nodes in the compilation space, and saves all output to `results/` after cross-checking.

Run the following command to get information of all available commands:

```
python3 -m tools.deploy --help
```

### Directory Description

```
.
├── core                # Source code of VeriXmith in Python
├── dependencies        # Patched versions or patches of KLEE, PySmt, and Verilator
├── Dockerfile
├── examples            # Verilog and SystemVerilog examples
├── README.md
├── requirements.txt    # Required Python packages
├── tasks.py            # A CLI-invokable wrapper for functions in core/api.py
└── tools               # Useful scripts (start Docker containers, process bug reports, etc.)
```

## Known limitations

1. Declaring a port as: (1) `output reg`; (2) `inout`; or (3) null; is not supported. This is caused by the Verilog frontend together with JSON backend of Yosys, which is adopted by VeriXmith to extract the input/output ports of the circuits.
2. Module named `main` will be renamed silently by Verilator, causing unexpected problems.
3. Escape names are not well supported by Yosys, e.g.:
   ```verilog
   // Generated by vlog-hammer
   module expression_00084;
      wire [5:0] \y11[0] ;
      wire [5:0] \y11[1] ;
      wire [5:0] \y11[2] ;
      wire [4:0] \y11[3] ;
      assign \y11[0]  = 6'h00;
      assign \y11[1]  = 6'h00;
      assign \y11[2]  = 6'h00;
      assign \y11[3] [3:0] = 4'hc;
   endmodule
   ```

Before performing cross-checking with any circuit design, make sure it is synthesizable, deterministic, and free of these patterns.
